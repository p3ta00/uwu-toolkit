from core.module_base import ModuleBase, ModuleType, Platform
import requests
import re
import base64
from urllib.parse import urljoin


class GiteaCommitSecrets(ModuleBase):
    def __init__(self):
        super().__init__()
        self.name = "gitea_commit_secrets"
        self.description = "Enumerate Gitea repositories and search commit history for hardcoded credentials, API tokens, and secrets"
        self.author = "HTB-Auto"
        self.module_type = ModuleType.AUXILIARY
        self.platform = Platform.MULTI
        self.tags = ["gitea", "git", "secrets", "credentials", "tokens", "enumeration", "recon"]

        # Target options
        self.register_option("RHOSTS", "Target Gitea host", required=True)
        self.register_option("RPORT", "Target Gitea port", required=True, default="3000")
        self.register_option("SSL", "Use HTTPS", required=False, default="false")
        
        # Authentication options
        self.register_option("TOKEN", "Personal Access Token for authentication", required=False, default="")
        self.register_option("USERNAME", "Username for basic auth", required=False, default="")
        self.register_option("PASSWORD", "Password for basic auth", required=False, default="")
        
        # Enumeration options
        self.register_option("REPO_OWNER", "Repository owner/organization to target (leave empty to enumerate all)", required=False, default="")
        self.register_option("REPO_NAME", "Specific repository name (leave empty to enumerate all)", required=False, default="")
        self.register_option("MAX_COMMITS", "Maximum commits to check per repository", required=False, default="100")
        self.register_option("BRANCHES", "Comma-separated list of branches to check (leave empty for all)", required=False, default="")
        
        # Output options
        self.register_option("OUTPUT_FILE", "File to save discovered secrets", required=False, default="")
        self.register_option("VERBOSE", "Show verbose output including commit messages", required=False, default="false")

        # Secret patterns to search for
        self.secret_patterns = {
            "AWS Access Key": r"AKIA[0-9A-Z]{16}",
            "AWS Secret Key": r"(?i)aws(.{0,20})?(?-i)['\"][0-9a-zA-Z\/+]{40}['\"]",
            "GitHub Token": r"gh[pousr]_[A-Za-z0-9_]{36,}",
            "GitLab Token": r"glpat-[A-Za-z0-9\-]{20,}",
            "Gitea Token": r"(?i)(gitea|token)[\s:=]+['\"]?[a-f0-9]{40}['\"]?",
            "Generic API Key": r"(?i)(api[_-]?key|apikey)[\s:=]+['\"]?[a-zA-Z0-9]{16,}['\"]?",
            "Generic Secret": r"(?i)(secret|password|passwd|pwd)[\s:=]+['\"]?[^\s'\"]{8,}['\"]?",
            "Bearer Token": r"(?i)bearer[\s]+[a-zA-Z0-9\-_.~+/]+=*",
            "Basic Auth": r"(?i)basic[\s]+[a-zA-Z0-9+/]+=*",
            "Private Key": r"-----BEGIN (RSA |EC |DSA |OPENSSH )?PRIVATE KEY-----",
            "JWT Token": r"eyJ[A-Za-z0-9-_]+\.eyJ[A-Za-z0-9-_]+\.[A-Za-z0-9-_.+/=]*",
            "Slack Token": r"xox[baprs]-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*",
            "Slack Webhook": r"https://hooks\.slack\.com/services/T[a-zA-Z0-9_]+/B[a-zA-Z0-9_]+/[a-zA-Z0-9_]+",
            "Discord Webhook": r"https://discord(?:app)?\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+",
            "Google API Key": r"AIza[0-9A-Za-z\-_]{35}",
            "Heroku API Key": r"(?i)heroku(.{0,20})?['\"][0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}['\"]",
            "MailChimp API Key": r"[0-9a-f]{32}-us[0-9]{1,2}",
            "Mailgun API Key": r"key-[0-9a-zA-Z]{32}",
            "Stripe API Key": r"sk_live_[0-9a-zA-Z]{24}",
            "Twilio API Key": r"SK[0-9a-fA-F]{32}",
            "SendGrid API Key": r"SG\.[a-zA-Z0-9_-]{22}\.[a-zA-Z0-9_-]{43}",
            "Database URL": r"(?i)(mysql|postgres|postgresql|mongodb|redis|mssql)://[^\s'\"]+",
            "Connection String": r"(?i)(server|host)=[^;]+;.*(user|uid)=[^;]+;.*(password|pwd)=[^;]+",
            "SSH Password": r"(?i)sshpass[\s]+-p[\s]+[^\s]+",
            "Base64 Credentials": r"(?i)(auth|credentials|creds)[\s:=]+[A-Za-z0-9+/]{20,}={0,2}",
        }

    def _get_base_url(self):
        """Construct base URL from options."""
        target = self.get_option("RHOSTS")
        port = self.get_option("RPORT")
        ssl = self.get_option("SSL").lower() == "true"
        protocol = "https" if ssl else "http"
        
        if (ssl and port == "443") or (not ssl and port == "80"):
            return f"{protocol}://{target}"
        return f"{protocol}://{target}:{port}"

    def _get_session(self):
        """Create authenticated session."""
        session = requests.Session()
        session.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
        
        token = self.get_option("TOKEN")
        username = self.get_option("USERNAME")
        password = self.get_option("PASSWORD")
        
        if token:
            session.headers["Authorization"] = f"token {token}"
        elif username and password:
            session.auth = (username, password)
            
        return session

    def _api_request(self, session, endpoint, params=None):
        """Make API request with error handling."""
        base_url = self._get_base_url()
        url = urljoin(base_url, f"/api/v1{endpoint}")
        
        try:
            response = session.get(url, params=params, timeout=30, verify=False)
            if response.status_code == 200:
                return response.json()
            elif response.status_code == 401:
                self.print_error(f"Authentication failed for {endpoint}")
                return None
            elif response.status_code == 403:
                self.print_warning(f"Access forbidden for {endpoint}")
                return None
            elif response.status_code == 404:
                return None
            else:
                self.print_warning(f"Unexpected status {response.status_code} for {endpoint}")
                return None
        except requests.exceptions.Timeout:
            self.print_error(f"Request timeout for {endpoint}")
            return None
        except requests.exceptions.ConnectionError:
            self.print_error(f"Connection error for {endpoint}")
            return None
        except Exception as e:
            self.print_error(f"Request error: {str(e)}")
            return None

    def _get_repositories(self, session):
        """Get list of repositories to enumerate."""
        repos = []
        repo_owner = self.get_option("REPO_OWNER")
        repo_name = self.get_option("REPO_NAME")
        
        if repo_owner and repo_name:
            # Specific repo requested
            repo = self._api_request(session, f"/repos/{repo_owner}/{repo_name}")
            if repo:
                repos.append(repo)
        elif repo_owner:
            # All repos for specific owner
            self.print_status(f"Enumerating repositories for owner: {repo_owner}")
            user_repos = self._api_request(session, f"/users/{repo_owner}/repos")
            if user_repos:
                repos.extend(user_repos)
            org_repos = self._api_request(session, f"/orgs/{repo_owner}/repos")
            if org_repos:
                repos.extend(org_repos)
        else:
            # Enumerate all accessible repos
            self.print_status("Enumerating all accessible repositories...")
            
            # Try to get explore/repos (public)
            explore_repos = self._api_request(session, "/repos/search", params={"limit": 100})
            if explore_repos and "data" in explore_repos:
                repos.extend(explore_repos["data"])
            
            # If authenticated, also get user's repos
            token = self.get_option("TOKEN")
            if token:
                user_repos = self._api_request(session, "/user/repos")
                if user_repos:
                    # Deduplicate
                    existing_ids = {r.get("id") for r in repos}
                    for repo in user_repos:
                        if repo.get("id") not in existing_ids:
                            repos.append(repo)
        
        return repos

    def _get_branches(self, session, owner, repo):
        """Get list of branches to check."""
        branches_opt = self.get_option("BRANCHES")
        
        if branches_opt:
            return [b.strip() for b in branches_opt.split(",") if b.strip()]
        
        branches_data = self._api_request(session, f"/repos/{owner}/{repo}/branches")
        if branches_data:
            return [b.get("name") for b in branches_data if b.get("name")]
        
        return ["main", "master"]  # Default fallback

    def _get_commits(self, session, owner, repo, branch, limit):
        """Get commit list for a branch."""
        commits = self._api_request(
            session, 
            f"/repos/{owner}/{repo}/commits",
            params={"sha": branch, "limit": limit}
        )
        return commits if commits else []

    def _get_commit_diff(self, session, owner, repo, sha):
        """Get diff for a specific commit."""
        base_url = self._get_base_url()
        url = f"{base_url}/{owner}/{repo}/commit/{sha}.diff"
        
        try:
            response = session.get(url, timeout=30, verify=False)
            if response.status_code == 200:
                return response.text
        except Exception:
            pass
        
        # Fallback: try API endpoint
        commit_data = self._api_request(session, f"/repos/{owner}/{repo}/git/commits/{sha}")
        if commit_data:
            # Get files changed
            files = commit_data.get("files", [])
            diff_content = ""
            for f in files:
                if "patch" in f:
                    diff_content += f"\n+++ {f.get('filename', 'unknown')}\n"
                    diff_content += f["patch"]
            return diff_content
        
        return None

    def _get_file_content(self, session, owner, repo, filepath, ref):
        """Get file content at specific ref."""
        file_data = self._api_request(
            session, 
            f"/repos/{owner}/{repo}/contents/{filepath}",
            params={"ref": ref}
        )
        
        if file_data and "content" in file_data:
            try:
                content = base64.b64decode(file_data["content"]).decode("utf-8", errors="ignore")
                return content
            except Exception:
                pass
        
        return None

    def _scan_for_secrets(self, content, context=""):
        """Scan content for secrets and return findings."""
        findings = []
        
        if not content:
            return findings
        
        for secret_type, pattern in self.secret_patterns.items():
            try:
                matches = re.finditer(pattern, content, re.MULTILINE)
                for match in matches:
                    # Get some context around the match
                    start = max(0, match.start() - 50)
                    end = min(len(content), match.end() + 50)
                    snippet = content[start:end].replace("\n", " ").strip()
                    
                    findings.append({
                        "type": secret_type,
                        "match": match.group(),
                        "context": context,
                        "snippet": f"...{snippet}..."
                    })
            except re.error:
                continue
        
        return findings

    def run(self) -> bool:
        target = self.get_option("RHOSTS")
        port = self.get_option("RPORT")
        max_commits = int(self.get_option("MAX_COMMITS"))
        verbose = self.get_option("VERBOSE").lower() == "true"
        output_file = self.get_option("OUTPUT_FILE")
        
        self.print_status(f"Starting Gitea commit secrets enumeration on {target}:{port}")
        
        # Suppress SSL warnings
        requests.packages.urllib3.disable_warnings()
        
        session = self._get_session()
        
        # Verify connectivity
        base_url = self._get_base_url()
        try:
            response = session.get(f"{base_url}/api/v1/version", timeout=10, verify=False)
            if response.status_code == 200:
                version_data = response.json()
                self.print_good(f"Connected to Gitea version: {version_data.get('version', 'unknown')}")
            else:
                self.print_warning("Could not verify Gitea version, continuing anyway...")
        except Exception as e:
            self.print_error(f"Failed to connect to Gitea: {str(e)}")
            return False
        
        # Get repositories
        repos = self._get_repositories(session)
        
        if not repos:
            self.print_warning("No repositories found or accessible")
            return False
        
        self.print_status(f"Found {len(repos)} repository(ies) to enumerate")
        
        all_findings = []
        
        for repo in repos:
            owner = repo.get("owner", {}).get("login") or repo.get("owner", {}).get("username")
            repo_name = repo.get("name")
            full_name = repo.get("full_name", f"{owner}/{repo_name}")
            
            if not owner or not repo_name:
                continue
            
            self.print_status(f"Scanning repository: {full_name}")
            
            # Get branches
            branches = self._get_branches(session, owner, repo_name)
            
            for branch in branches:
                if verbose:
                    self.print_status(f"  Checking branch: {branch}")
                
                commits = self._get_commits(session, owner, repo_name, branch, max_commits)
                
                if not commits:
                    continue
                
                if verbose:
                    self.print_status(f"  Found {len(commits)} commits to analyze")
                
                for commit in commits:
                    sha = commit.get("sha")
                    message = commit.get("commit", {}).get("message", "")[:80] if isinstance(commit.get("commit"), dict) else ""
                    
                    if not sha:
                        continue
                    
                    # Get commit diff
                    diff = self._get_commit_diff(session, owner, repo_name, sha)
                    
                    if diff:
                        context = f"{full_name}@{branch} - {sha[:8]}"
                        if message and verbose:
                            context += f" ({message})"
                        
                        findings = self._scan_for_secrets(diff, context)
                        
                        for finding in findings:
                            finding["repo"] = full_name
                            finding["branch"] = branch
                            finding["commit"] = sha
                            finding["commit_message"] = message
                            all_findings.append(finding)
                            
                            self.print_good(f"  [SECRET FOUND] {finding['type']}")
                            self.print_good(f"    Commit: {sha[:8]} on {branch}")
                            self.print_good(f"    Match: {finding['match'][:100]}...")
        
        # Summary
        self.print_status("-" * 60)
        
        if all_findings:
            self.print_good(f"Total secrets found: {len(all_findings)}")
            
            # Group by type
            types_found = {}
            for f in all_findings:
                t = f["type"]
                types_found[t] = types_found.get(t, 0) + 1
            
            self.print_status("Breakdown by type:")
            for secret_type, count in sorted(types_found.items(), key=lambda x: -x[1]):
                self.print_status(f"  {secret_type}: {count}")
            
            # Save to file if requested
            if output_file:
                try:
                    with open(output_file, "w") as f:
                        f.write("# Gitea Commit Secrets Scan Results\n\n")
                        f.write(f"Target: {target}:{port}\n")
                        f.write(f"Total findings: {len(all_findings)}\n\n")
                        
                        for finding in all_findings:
                            f.write("-" * 40 + "\n")
                            f.write(f"Type: {finding['type']}\n")
                            f.write(f"Repository: {finding['repo']}\n")
                            f.write(f"Branch: {finding['branch']}\n")
                            f.write(f"Commit: {finding['commit']}\n")
                            f.write(f"Message: {finding['commit_message']}\n")
                            f.write(f"Match: {finding['match']}\n")
                            f.write(f"Context: {finding['snippet']}\n\n")
                    
                    self.print_good(f"Results saved to: {output_file}")
                except Exception as e:
                    self.print_error(f"Failed to save results: {str(e)}")
            
            return True
        else:
            self.print_warning("No secrets found in commit history")
            return False
